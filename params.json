{"name":"Verilog Plusargs","tagline":"Verilog Plusargs","body":"In Verilog, plusargs can be used to change the behavior of a program without recompiling. This can be great if there are a lot of tests to run with the same testbench.\r\n\r\nThere are two calls for plusargs in Verilog: `$test$plusargs` and `$value$plusargs`.\r\n\r\nThe first call, `$test$plusargs(\"string\")`, returns a boolean value. If the plusarg given by `\"string\"` was passed into the program at runtime, the call returns true. Otherwise, the call returns false.\r\n\r\nThe second call, `$value$plusargs(\"string=%d\", val)`, also returns a boolean value depending on if the plusarg given by `\"string\"` was passed in. It also will load the register given by `val` based on the format given by `%d` in this example. Here is the list of formats available:\r\n\r\nFormat | Description\r\n------ | -----------\r\n`%b` | read as binary value\r\n`%o` | read as octal value\r\n`%d` | read as decimal value\r\n`%h` | read as hex value\r\n`%e` | read as real value, exponential format\r\n`%f` | read as real value, decimal format\r\n`%g` | read as real value, shortest format\r\n`%s` | read as character string\r\n\r\nNote that the `$value$plusargs` call is available since Verilog-2001. Before that, Verilog only supported the `$test$plusargs` call.\r\n\r\nHere's a simple example. Here, the `my_port` variable is set to `1234` by default, unless the `+port=` plusarg is passed in on the command line when running the executable.\r\n\r\n```verilog\r\nmodule test;\r\nint my_port;\r\n\r\ninitial begin\r\n  if (!$value$plusargs(\"port=%d\", my_port)) begin\r\n    my_port = 32'd1234;\r\n  end\r\n\r\n  $display(\"my_port = %-d\", my_port);\r\n\r\nend\r\nendmodule\r\n```\r\n\r\nHere is the invocation for compiling the file (using VCS):\r\n\r\n```\r\n% vcs +v2k -sverilog test.sv\r\n```\r\n\r\nAnd here is the invocation for running said program (again, using VCS):\r\n\r\n```\r\n% simv\r\nmy_port = 1234\r\n```\r\n\r\nNow, when passing in the `+port=5678` plusarg, here is the invocation and results:\r\n\r\n```\r\n% simv +port=5678\r\nmy_port = 5678\r\n```\r\n\r\nAs you can see, no recompilation is necessary.\r\n\r\nNow, say that you need to read in an array of plusargs. This might be useful for creating a look-up table of plusargs.\r\n\r\n```verilog\r\nmodule test2;\r\n\r\n// Associative array with default values\r\nint plusargs[string] = '{\"a\":1, \"b\":2, \"c\":3};\r\n\r\ninitial begin\r\n\r\n  get_plusarg(\"a\");\r\n  get_plusarg(\"b\");\r\n  get_plusarg(\"c\");\r\n\r\n  foreach (plusargs[s]) begin\r\n    $display(\"plusargs[%s] = %-d\", s, plusargs[s]);\r\n  end\r\n\r\nend\r\n\r\nfunction void get_plusarg(string name);\r\n  $value$plusargs({name, \"=%d\"}, plusargs[name]);\r\nendfunction\r\n\r\nendmodule\r\n```\r\n\r\nWe can compile with the following:\r\n\r\n```\r\n% vcs +v2k -sverilog test2.sv\r\n```\r\n\r\nAnd run with the following:\r\n\r\n```\r\n% simv\r\nplusargs[a] = 1\r\nplusargs[b] = 2\r\nplusargs[c] = 3\r\n```\r\n\r\nWith plusargs:\r\n\r\n```\r\n% simv +a=12 +b=15\r\nplusargs[a] = 12\r\nplusargs[b] = 15\r\nplusargs[c] = 3\r\n```\r\n\r\nReferences:\r\n\r\n* http://stackoverflow.com/questions/16361272/passing-string-variables-to-plusargs-in-system-verilog\r\n* http://www.sutherland-hdl.com/papers/2002-DesignCon-tutorial_using_Verilog-2001_part2.pdf\r\n\r\n","google":"UA-46520210-1","note":"Don't delete this file! It's used internally to help with page regeneration."}